
# fluorite9 日本語版ドキュメント

**目次**

<!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->

- [値](#%E5%80%A4)
  - [数値](#%E6%95%B0%E5%80%A4)
  - [文字列](#%E6%96%87%E5%AD%97%E5%88%97)
  - [論理値](#%E8%AB%96%E7%90%86%E5%80%A4)
- [トークン](#%E3%83%88%E3%83%BC%E3%82%AF%E3%83%B3)
  - [空白](#%E7%A9%BA%E7%99%BD)
  - [空白と改行](#%E7%A9%BA%E7%99%BD%E3%81%A8%E6%94%B9%E8%A1%8C)
    - [改行可能な場所](#%E6%94%B9%E8%A1%8C%E5%8F%AF%E8%83%BD%E3%81%AA%E5%A0%B4%E6%89%80)
    - [`\`による改行の打ち消し](#%5C%E3%81%AB%E3%82%88%E3%82%8B%E6%94%B9%E8%A1%8C%E3%81%AE%E6%89%93%E3%81%A1%E6%B6%88%E3%81%97)
- [演算子](#%E6%BC%94%E7%AE%97%E5%AD%90)
  - [整数リテラル `123`](#%E6%95%B4%E6%95%B0%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB-123)
  - [文字列リテラル `'abc'`](#%E6%96%87%E5%AD%97%E5%88%97%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB-abc)
    - [絶対文字](#%E7%B5%B6%E5%AF%BE%E6%96%87%E5%AD%97)
  - [埋め込み文字列リテラル `"abc"`](#%E5%9F%8B%E3%82%81%E8%BE%BC%E3%81%BF%E6%96%87%E5%AD%97%E5%88%97%E3%83%AA%E3%83%86%E3%83%A9%E3%83%AB-abc)
    - [文字参照 `"\n"`](#%E6%96%87%E5%AD%97%E5%8F%82%E7%85%A7-%5Cn)
    - [埋め込み `"$identifier"` `"$(formula)"`](#%E5%9F%8B%E3%82%81%E8%BE%BC%E3%81%BF-identifier-formula)
    - [フォーマット付き埋め込み `"$%05s(formula)"`](#%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%83%E3%83%88%E4%BB%98%E3%81%8D%E5%9F%8B%E3%82%81%E8%BE%BC%E3%81%BF-sformula)
  - [EFL `%>string<%`](#efl-string)
    - [原理](#%E5%8E%9F%E7%90%86)
    - [`<%`自身の埋め込み `<%%`](#%E8%87%AA%E8%BA%AB%E3%81%AE%E5%9F%8B%E3%82%81%E8%BE%BC%E3%81%BF-)
  - [識別子 `identifier`](#%E8%AD%98%E5%88%A5%E5%AD%90-identifier)
  - [空括弧 `()`](#%E7%A9%BA%E6%8B%AC%E5%BC%A7-)
  - [括弧 `(formula)`](#%E6%8B%AC%E5%BC%A7-formula)
  - [配列初期化子 `[item; ...]`](#%E9%85%8D%E5%88%97%E5%88%9D%E6%9C%9F%E5%8C%96%E5%AD%90-item-)
    - [ストリームの展開](#%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%A0%E3%81%AE%E5%B1%95%E9%96%8B)
  - [オブジェクト初期化子 `{key = value; ...}`](#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E5%88%9D%E6%9C%9F%E5%8C%96%E5%AD%90-key--value-)
    - [式によるキーの指定 `{(formula) = value}`](#%E5%BC%8F%E3%81%AB%E3%82%88%E3%82%8B%E3%82%AD%E3%83%BC%E3%81%AE%E6%8C%87%E5%AE%9A-formula--value)
  - [ブロック呼び出し `function(closure)`](#%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97-functionclosure)
  - [関数呼び出し `function[argument; ...]`](#%E9%96%A2%E6%95%B0%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%97-functionargument-)
    - [配列要素アクセス `array[index]`](#%E9%85%8D%E5%88%97%E8%A6%81%E7%B4%A0%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9-arrayindex)
    - [配列のストリーム展開 `array[]`](#%E9%85%8D%E5%88%97%E3%81%AE%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%A0%E5%B1%95%E9%96%8B-array)
    - [名前付き引数 `name : value`](#%E5%90%8D%E5%89%8D%E4%BB%98%E3%81%8D%E5%BC%95%E6%95%B0-name--value)
    - [引数の省略](#%E5%BC%95%E6%95%B0%E3%81%AE%E7%9C%81%E7%95%A5)
  - [デリゲートアクセス `object::method`](#%E3%83%87%E3%83%AA%E3%82%B2%E3%83%BC%E3%83%88%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9-objectmethod)
    - [厳密な挙動の説明](#%E5%8E%B3%E5%AF%86%E3%81%AA%E6%8C%99%E5%8B%95%E3%81%AE%E8%AA%AC%E6%98%8E)
  - [JSONエンコード・デコード演算子 `$&value` `$*json`](#json%E3%82%A8%E3%83%B3%E3%82%B3%E3%83%BC%E3%83%89%E3%83%BB%E3%83%87%E3%82%B3%E3%83%BC%E3%83%89%E6%BC%94%E7%AE%97%E5%AD%90-value-json)
    - [後置版 `value.$&` `json.$*`](#%E5%BE%8C%E7%BD%AE%E7%89%88-value-json)
  - [四則演算 `left + right` `left - right` `left * right` `left / right`](#%E5%9B%9B%E5%89%87%E6%BC%94%E7%AE%97-left--right-left---right-left--right-left--right)
    - [基本](#%E5%9F%BA%E6%9C%AC)
    - [余りの出る除算 `left / right`](#%E4%BD%99%E3%82%8A%E3%81%AE%E5%87%BA%E3%82%8B%E9%99%A4%E7%AE%97-left--right)
    - [文字列結合 `"left" + "right"`](#%E6%96%87%E5%AD%97%E5%88%97%E7%B5%90%E5%90%88-left--right)
    - [文字列の繰り返し `"string" * number`](#%E6%96%87%E5%AD%97%E5%88%97%E3%81%AE%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97-string--number)
    - [配列の結合 `[left] + [right]`](#%E9%85%8D%E5%88%97%E3%81%AE%E7%B5%90%E5%90%88-left--right)
    - [配列の繰り返し `[array] * number`](#%E9%85%8D%E5%88%97%E3%81%AE%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97-array--number)
    - [型の自動変換](#%E5%9E%8B%E3%81%AE%E8%87%AA%E5%8B%95%E5%A4%89%E6%8F%9B)
    - [オーバーライド](#%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89)
  - [範囲演算子 `start .. end` `start ~ endExcluded`](#%E7%AF%84%E5%9B%B2%E6%BC%94%E7%AE%97%E5%AD%90-start--end-start--endexcluded)
    - [ストリーム生成](#%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%A0%E7%94%9F%E6%88%90)
    - [閉区間と半開区間](#%E9%96%89%E5%8C%BA%E9%96%93%E3%81%A8%E5%8D%8A%E9%96%8B%E5%8C%BA%E9%96%93)
  - [等号演算子 `actual == expected` `actual === expected` `actual != notExpected` `actual !== notExpected`](#%E7%AD%89%E5%8F%B7%E6%BC%94%E7%AE%97%E5%AD%90-actual--expected-actual--expected-actual--notexpected-actual--notexpected)
    - [暗黙の型変換](#%E6%9A%97%E9%BB%99%E3%81%AE%E5%9E%8B%E5%A4%89%E6%8F%9B)
    - [配列・オブジェクトの扱い【未実装の項目】](#%E9%85%8D%E5%88%97%E3%83%BB%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E6%89%B1%E3%81%84%E6%9C%AA%E5%AE%9F%E8%A3%85%E3%81%AE%E9%A0%85%E7%9B%AE)
    - [演算子オーバーライド【未実装の項目】](#%E6%BC%94%E7%AE%97%E5%AD%90%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89%E6%9C%AA%E5%AE%9F%E8%A3%85%E3%81%AE%E9%A0%85%E7%9B%AE)
    - [NANおよび-0の扱い](#nan%E3%81%8A%E3%82%88%E3%81%B3-0%E3%81%AE%E6%89%B1%E3%81%84)
    - [連鎖 `a == b == c`](#%E9%80%A3%E9%8E%96-a--b--c)
  - [不等号演算子 `left > right` `left >= right` `left < right` `left <= right`](#%E4%B8%8D%E7%AD%89%E5%8F%B7%E6%BC%94%E7%AE%97%E5%AD%90-left--right-left--right-left--right-left--right)
    - [演算子オーバーライド【未実装の項目】](#%E6%BC%94%E7%AE%97%E5%AD%90%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89%E6%9C%AA%E5%AE%9F%E8%A3%85%E3%81%AE%E9%A0%85%E7%9B%AE-1)
    - [連鎖 `a < b < c`](#%E9%80%A3%E9%8E%96-a--b--c-1)
  - [論理演算子 `left && right` `left || right`](#%E8%AB%96%E7%90%86%E6%BC%94%E7%AE%97%E5%AD%90-left--right-left--right)
    - [条件文としての論理演算子](#%E6%9D%A1%E4%BB%B6%E6%96%87%E3%81%A8%E3%81%97%E3%81%A6%E3%81%AE%E8%AB%96%E7%90%86%E6%BC%94%E7%AE%97%E5%AD%90)
  - [三項演算子 `condition ? then : else`](#%E4%B8%89%E9%A0%85%E6%BC%94%E7%AE%97%E5%AD%90-condition--then--else)
  - [エルビス演算子 `left ?: right`](#%E3%82%A8%E3%83%AB%E3%83%93%E3%82%B9%E6%BC%94%E7%AE%97%E5%AD%90-left--right)
  - [逆エルビス演算子 `left !: right`](#%E9%80%86%E3%82%A8%E3%83%AB%E3%83%93%E3%82%B9%E6%BC%94%E7%AE%97%E5%AD%90-left--right)
  - [try演算子 `try !? catch`](#try%E6%BC%94%E7%AE%97%E5%AD%90-try--catch)
  - [コンマ `item, ...`](#%E3%82%B3%E3%83%B3%E3%83%9E-item-)
  - [ラムダ式 `arguments -> body`](#%E3%83%A9%E3%83%A0%E3%83%80%E5%BC%8F-arguments---body)
    - [引数](#%E5%BC%95%E6%95%B0)
    - [高階関数](#%E9%AB%98%E9%9A%8E%E9%96%A2%E6%95%B0)
  - [変数宣言 `var : val`](#%E5%A4%89%E6%95%B0%E5%AE%A3%E8%A8%80-var--val)
  - [代入 `var = val`](#%E4%BB%A3%E5%85%A5-var--val)
  - [パイプ `stream | mapper`](#%E3%83%91%E3%82%A4%E3%83%97-stream--mapper)
    - [変数名の指定 `stream | arg => mapper`](#%E5%A4%89%E6%95%B0%E5%90%8D%E3%81%AE%E6%8C%87%E5%AE%9A-stream--arg--mapper)
  - [文 `line; ...` `line\n...`](#%E6%96%87-line--line%5Cn)
    - [式と文](#%E5%BC%8F%E3%81%A8%E6%96%87)
    - [丸括弧と文](#%E4%B8%B8%E6%8B%AC%E5%BC%A7%E3%81%A8%E6%96%87)
- [consoleライブラリ](#console%E3%83%A9%E3%82%A4%E3%83%96%E3%83%A9%E3%83%AA)
  - [`IN`定数](#in%E5%AE%9A%E6%95%B0)
  - [`READ[file]`関数](#readfile%E9%96%A2%E6%95%B0)
  - [`JS[code]`関数](#jscode%E9%96%A2%E6%95%B0)
  - [`REQUIRE[name]`関数](#requirename%E9%96%A2%E6%95%B0)
- [コンソール](#%E3%82%B3%E3%83%B3%E3%82%BD%E3%83%BC%E3%83%AB)
  - [fl9](#fl9)
    - [ソースコード全体の戻り値の出力](#%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%B3%E3%83%BC%E3%83%89%E5%85%A8%E4%BD%93%E3%81%AE%E6%88%BB%E3%82%8A%E5%80%A4%E3%81%AE%E5%87%BA%E5%8A%9B)
    - [EFLモード `-e`](#efl%E3%83%A2%E3%83%BC%E3%83%89--e)
  - [fl9e](#fl9e)
- [イディオム](#%E3%82%A4%E3%83%87%E3%82%A3%E3%82%AA%E3%83%A0)
  - [簡易的なCSV出力](#%E7%B0%A1%E6%98%93%E7%9A%84%E3%81%AAcsv%E5%87%BA%E5%8A%9B)
- [高度なチュートリアル](#%E9%AB%98%E5%BA%A6%E3%81%AA%E3%83%81%E3%83%A5%E3%83%BC%E3%83%88%E3%83%AA%E3%82%A2%E3%83%AB)
  - [オブジェクト指向](#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91)
    - [オブジェクトの生成](#%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E3%81%AE%E7%94%9F%E6%88%90)
    - [メソッド](#%E3%83%A1%E3%82%BD%E3%83%83%E3%83%89)
  - [演算子オーバーライド](#%E6%BC%94%E7%AE%97%E5%AD%90%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89)
  - [デバッグ](#%E3%83%87%E3%83%90%E3%83%83%E3%82%B0)

<!-- END doctoc generated TOC please keep comment here to allow auto update -->

# 値

## 数値

fl9には数値が1種類だけ存在します。
整数と浮動小数の区別はなく、合わせて数値（number）です。

## 文字列

fl9の文字列は内部的にUnicode形式で格納されています。

## 論理値

TRUEとFALSEの2値が存在します。

# トークン

## 空白

fl9では次の文字は空白文字として扱われます。

- 半角空白 ` `
- タブ文字 `\t`
- 改行 `\r\n` `\r` `\n`
- バックスラッシュ `\`

空白文字はトークンとトークンの間に自由に置くことができます。
ただし、一部の場所では改行を置くことはできません。

## 空白と改行

fl9は`;`もしくは改行によって文を分離します。
特殊な場合を除いて、改行をした場合は`;`を省略することが推奨されています。

```
a : 0
f : () ->
  a = a + 1
1 .. 7 | f[]
f[]
a
```
↓
```
8
```

トークンの間にはいくつでもスペースを入れてコードを整形できます。
文の区切りとあいまいにならない限り、自由に改行を行うこともできます。

```
       a :
    0

f :
         () ->

a =
           a +

1
       1 ..
7 |


f[
    ]
           f[


    ]
a
```
↓
```
8
```

### 改行可能な場所

文の区切りを意図しない改行は、次の場所でのみ可能です。

- ソースコード全体の先頭および末尾
- 括弧類のすぐ内側
- 前後両方に項を取る演算子の直後（三項演算子も含む）
- アクセス系演算子の直前
- 括弧類でない後置演算子の直前

中置演算子の左側で改行することはできません。
次のコードは3個の文として解釈されます。

```
"abc"
  + "def"
  + "ghi"
```

### `\`による改行の打ち消し

fl9において`\`は空白文字として扱われます。
空白文字の塊の中に`\`がある場合、その位置で改行によって文が分割されることはありません。
これにより、本来改行ができない位置で改行を行うことができます。

```
"abc"

  \+ "def"

  \+ "ghi"
```
↓
```
abcdefghi
```

`\`は改行の前と後のどちらに置いてもかまいません。
`\`のあとに複数の改行がある場合、それらの改行はまとめて無視されます。

# 演算子

## 整数リテラル `123`

整数を書くと整数になります。

```
1
```

```
123456
```

先頭が`0`で始まっても常に10進数です。

```
0010
```
↓
```
10
```

## 文字列リテラル `'abc'`

シングルクォート`'`で囲むと文字列が作れます。

```
'abc'
```

### 絶対文字

`\`は、そのあとに続くいかなる文字もそのまま保持します。
`'`自体を含める場合にも`\'`と書きます。

```
' \' \\ \n '
```
↓
```
 ' \ n 
```

## 埋め込み文字列リテラル `"abc"`

ダブルクォート`"`で囲むと文字列が作れます。

```
"abc"
```

### 文字参照 `"\n"`

埋め込み文字列リテラルでは`\`は直後に続く文字に応じて特別な働きをします。

```
" \" \\ [\n] [\t] \$ "
```
↓
```
 " \ [
] [	] $ 
```

### 埋め込み `"$identifier"` `"$(formula)"`

埋め込み文字列リテラル内では、`$identifier`によって変数を埋め込むことができます。

```
"[$PI]"
```
↓
```
[3.141592653589793]
```

`$(formula)`で式を埋め込みます。

```
"[$(PI * 100)]"
```
↓
```
[314.1592653589793]
```

### フォーマット付き埋め込み `"$%05s(formula)"`

埋め込みの`$`と`( )`の間にC言語のprintfに似通った文法のフォーマット指定子を書くことで、文字列への埋め込みのフォーマットを制御できます。

例えば`%5s`では、5文字に満たない文字列を左側に半角スペースで埋めて文字列化します。

```
"[$%5s(123)]"
``` 
↓
```
[  123]
```

半角スペースではなく`0`で埋める場合は`%5s`のように書きます。

```
"[$%05s(123)]"
``` 
↓
```
[00123]
```

実はフォーマット付き埋め込みは`" "`の内部でなくとも記述できます。

```
$%05s(123)
``` 
↓
```
00123
```

## EFL `%>string<%`

EFL（Embedded Fluorite）は文書中にfl9コードを注入する仕組みです。

`%>'と'<%`で囲まれた部分はHTMLなどのテキスト部分として解釈されます。
`<%='と'%>`で囲まれた部分はfl9コードとして解釈され、その値が文字列としてテキスト中に埋め込まれます。

EFLの中では、改行・`"`・`'`・`\`・`$`などの文字は通常の文字として扱われ、特殊な働きをしません。
その代わり、`<%`が終端や埋め込みのトリガーになります。

```
title : "Test Page"
message : "Hello, World!"

%>
<html>
  <head>
    <title><%= title %></title>
  </head>
  <body>
    <h1><%= title %></h1>
    <p><%= message %></p>
  </body>
</html>
<%
```
↓
```
<html>
  <head>
    <title>Test Page</title>
  </head>
  <body>
    <h1>Test Page</h1>
    <p>Hello, World!</p>
  </body>
</html>
```

### 原理

EFLの実態は、「変わった見た目をした埋め込み可能な文字列リテラル」です。
そのため、結果を変数に代入することや文字列として加工することもできます。
EFLそのものには標準出力などに出力する機能はありません。

```
string : %>abcde<%

"===== " + string + " ====="
```
↓
```
===== abcde =====
```

### `<%`自身の埋め込み `<%%`

`<%%`と書くと`<%`を埋め込むことができます。

```
%>===== <%% =====<%
```
↓
```
===== <% =====
```

## 識別子 `identifier`

識別子は1文字以上で、利用できる文字は`[a-zA-Z0-9_]`です。
ただし先頭の文字に数字を置くことはできません。

fl9にはいくつかの組み込み定数が存在します。

```
PI
```
↓
```
3.141592653589793
```

## 空括弧 `()`

空括弧は要素が0個のストリームを返します。

## 括弧 `(formula)`

丸括弧はただの括弧です。
丸括弧の中には単一の識別子や文字列などの他、式を書くこともできます。

丸括弧はそれで一つの塊になるため、計算順序の変更に使うことができます。

```
10 * (3 + 7)
```
↓
```
100
```

## 配列初期化子 `[item; ...]`

配列初期化子は配列を生成するのに使います。
配列要素には型はなく、入れ子状の配列を含む、どんな値でも入れることができます。

```
[]
```

```
[
  [
    100
  ]
]
```

配列要素は`;`もしくは改行で区切ります。

```
[123; "abc"]
```
↓
```
123,abc
```

```
[
  123
  "abc"
]
```
↓
```
123,abc
```

`;`を冗長に記述した場合、単に無視されます。

```
[
  ;
  1;
  2;;;;
  3;;;
]
```
↓
```
1,2,3
```

### ストリームの展開

配列要素に直接ストリームが現れた場合、常に自動的に展開します。
範囲や空括弧はストリームです。

```
[1 .. 3; 4, 5, 6; (); 7]
```
↓
```
1,2,3,4,5,6,7
```

配列内の配列やNULLやUNDEFINEDは展開されずにそのまま保持されます。

```
array : [
  "zero"
  [1 .. 10]
  "two"
  (3 .. 5)
  "six"
  NULL
  UNDEFINED
  "nine"
]

array[9]
```
↓
```
nine
```

この性質のため、配列の要素はよく`,`で区切って記述されます。

## オブジェクト初期化子 `{key = value; ...}`

オブジェクト初期化子を使ってオブジェクトを生成できます。
`{ }`内部では、`=`で区切られたキー・値の組を`;`もしくは改行で区切って並べます。

配列初期化子と同様、無意味な`;`は単に無視されます。

```
{
  a = 123
  b = [
    456
    789
  ]
}
```
↓
```
a:123;b:456,789;
```

### 式によるキーの指定 `{(formula) = value}`

キーの部分に`( )`で囲われた式を指定すると、その値を評価してキー名にします。

```
{
  ("label_" + 1) = "One"
}
```
↓
```
label_1:One;
```

これは演算子オーバーライドを行うのに必須です。

```
obj : {
  (OPERATOR_ADD) = left, right -> 4 + right
}

obj + 6
```
↓
```
10
```

## 関数呼び出し `function[argument; ...]`

fl9では関数の呼び出しに角括弧`[ ]`を使います。

```
SIN[PI / 6]
```
↓
```
0.49999999999999994
```

関数の引数は`;`で区切ります。

```
LOG[256; 2]
```
↓
```
8
```

### 配列要素アクセス `array[index]`

配列に対して1個の引数で関数呼び出しを行うと配列要素アクセスになります。
添え字は0から始まります。

```
array : [10, 20, 30, 40, 50]
array[3]
```
↓
```
40
```

### 配列のストリーム展開 `array[]`

配列に対して0個の引数で関数呼び出しを行うと、配列の要素を先頭から返すストリームを生成します。

```
array : [10, 20, 30, 40, 50]
array[]
```
↓
```
10
20
30
40
50
```

パイプ演算子などのストリームを加工する手段を使うことができます。

```
array : [10, 20, 30, 40, 50]
array[] | _ * _
```
↓
```
100
400
900
1600
2500
```

### 名前付き引数 `name : value`

1個以上の名前付き引数が与えられている場合、それらはまとめて一つのオブジェクトとして引数列の最後に挿入されます。

```
f : a, b, args -> [a, b, args]
f[
  1
  2
  arg1 : 3
  arg2 : 4
]
```
↓
```
1,2,arg1:3;arg2:4;
```

### 引数の省略

引数を省略するとUNDEFINEDとなります。

```
f : a, b -> [a, b]
f[1]
```
↓
```
1,UNDEFINED
```

引数列の途中を省略することもできます。

```
f : a, b, c -> [a, b, c]
f[; ; 3]
```
↓
```
UNDEFINED,UNDEFINED,3
```

関数呼び出しの引数列における`;`は、余計に記述するとその分省略された引数が増えることに気を付けてください。
引数列の最後に余計に`;`を記述した場合、実は末尾にUNDEFINEDが一つ追加されています。
この仕様は、引数の個数によって処理を分岐している関数の呼び出しに影響を与えます。

```
LOG[
  10
]
```
↓
```
2.302585092994046
```

```
LOG[
  10;
]
```
↓
```
0
```

ただし、一度でも名前付き引数が現れた場合、以降の冗長な`;`は単に無視されます。
次のコードは引数列の末尾に冗長な`;`が含まれますが、`args`が名前付き引数の組を受け付けます。

```
f : args -> args
f[
  arg1 : 1;
  arg2 : 2;
  arg3 : 3;
]
```
↓
```
arg1:1;arg2:2;arg3:3;
```

### クロージャによる関数呼び出し `function (closure)` `function[argument; ...] (closure)...`

`closure`部分に記述した式は、関数として`argument`列の末尾に追加された状態で`function`に渡されます。

```
iterate : mapper -> (1 .. 5 | mapper[_])

iterate (50)
```
↓
```
50
50
50
50
50
```

----

`closure`部分では`args =>`によりクロージャが受け取る引数列を指定できます。

```
iterate : mapper -> (1 .. 5 | mapper[_])

iterate (x => x * x)
```
↓
```
1
4
9
16
25
```

----

クロージャは通常の引数列と同時に利用することができます。

```
map : stream, mapper -> (stream | mapper[_])

map[1 .. 5] (x => x * x)
```
↓
```
1
4
9
16
25
```

名前付き引数も同時に使用した場合、通常の引数列→名前付き引数→クロージャの順で関数に適用されます。
これはNode.jsの`http.request(url[, options][, callback])`関数のようなAPIを呼び出すのに向いています。

----

クロージャを複数指定することで、制御構文のような見た目の関数が実装できます。

```
if : condition, then, else -> condition[] ? then[] : else[]

1 .. 5 | (

  if (_ % 2 == 0) (
    "$_ is Even"
  ) (
    "$_ is Odd"
  )

)
```
↓
```
1 is Odd
2 is Even
3 is Odd
4 is Even
5 is Odd
```

## デリゲートアクセス `object::method`

オブジェクトのメソッドを呼ぶのに使います。

```
object : {
  value = 123
  getValue = this -> this.value
}

object::getValue[]
```
↓
```
123
```

メソッドはthis以外に引数を取ってもかまいません。

### 厳密な挙動の説明

デリゲートアクセス演算子はその場で呼び出すだけでなく、オブジェクトとメソッド名の組の状態で持っておくことができます。

```
delegate : object::getValue
```

上のコードは、次のコードと概ね等価です。

```
delegate : () -> object.getValue[object]
```

デリゲートアクセス演算子は、オブジェクトのプロパティを参照したうえで、それを関数とみなしてオブジェクト自身を左に部分適用した関数を返します。

## JSONエンコード・デコード演算子 `$&value` `$*json`

`$&`はオブジェクト、配列、数値、文字列などJSON化できるものを整形されたJSON文字列に変換します。

```
$&[
  1
  2
  [3, 4]
  5
  {
    a = 6
    b = [7, 8]
  }
  "9"
  TRUE
  NULL
]
```
↓
```
[
 1,
 2,
 [
  3,
  4
 ],
 5,
 {
  "a": 6,
  "b": [
   7,
   8
  ]
 },
 "9",
 true,
 null
]
```

`$*`はJSON文字列からオブジェクトと配列を構成します。

```
$*"[1, 2, 3]"
```
↓
```
1,2,3
```

どちらの演算子も、配列やオブジェクト以外の値を直接処理することができます。

```
$&"abc"
```
↓
```
"abc"
```

### 後置版 `value.$&` `json.$*`

全く同じ働きをする後置演算子も存在します。

## 四則演算 `left + right` `left - right` `left * right` `left / right`

### 基本

数値同士の四則演算をサポートしています。
乗除演算子は加減演算子よりも優先的に結合します。

```
106 + 20 * 2 - 8 / 2
```
↓
```
142
```

### 余りの出る除算 `left / right`

除算で余りが出る場合は自動的に浮動小数になります。

```
10 / 3
```
↓
```
3.3333333333333335
```

### 文字列結合 `"left" + "right"`

文字列の加算は、たとえそれが整数と解釈可能な内容であっても、文字列の結合になります。

```
"123" + "456"
```
↓
```
123456
```

### 文字列の繰り返し `"string" * number`

文字列に数値を乗じると、その回数だけ反復します。

```
"123" * 4
```
↓
```
123123123123
```

### 配列の結合 `[left] + [right]`

配列に対して配列を加算すると、それらを結合した配列を新規に生成して返します。

```
[1, 2, 3] + [4, 5, 6]
```
↓
```
1,2,3,4,5,6
```

### 配列の繰り返し `[array] * number`

配列に整数を乗じると、その回数だけ反復します。

```
[1, 2, 3] * 4
```
↓
```
1,2,3,1,2,3,1,2,3,1,2,3
```

### 型の自動変換

右辺の型が左辺によって期待される型でない場合、自動的に型変換が行われます。

例えば、左辺が数値型であれば、右辺が文字列型であっても`+`演算子の挙動は数値の加算となります。

```
123 + "456"
```
↓
```
579
```

### オーバーライド

オブジェクトは四則演算の挙動を次のシンボル名のメソッドで受けます。

- `(OPERATOR_ADD)`
- `(OPERATOR_SUBTRACT)`
- `(OPERATOR_MULTIPLY)`
- `(OPERATOR_DIVIDE)`

```
obj : {
  (OPERATOR_ADD) = left, right -> 4 + right
}

obj + 6
```
↓
```
10
```

## 剰余演算子 `left % right`

`%`で余りを得ます。
結合優先度は乗除算と同じです。

## 範囲演算子 `start .. end` `start ~ endExcluded`

左辺と右辺の間を表す演算子です。

### ストリーム生成

範囲演算子の一般的な用途は、ストリームを生成することです。

```
1 .. 3
```
↓
```
1
2
3
```

ストリームは、ストリームを受け付ける演算子で加工することができます。

```
1 .. 3 | _ * _
```
↓
```
1
4
9
```

### 閉区間と半開区間
 
`..`は閉区間で、右辺の値を含みます。
`~`は半開区間で、右辺の値を含みません。

```
1 ~ 3
```
↓
```
1
2
```

`~`は配列をインデックスでイテレートするのに便利です。

```
array : [1, 2, 3]
0 ~ $#array
```
↓
```
0
1
2
```

## 等号演算子 `actual == expected` `actual === expected` `actual != notExpected` `actual !== notExpected`

`==`は抽象的な等号演算子で、左辺の値が右辺に等しいか否かを判定します。
`!=`はその値を単純に反転したものです。

```
[
  10 == 10
  10 != 10
  10 == 100
  10 != 100
]
```
↓
```
TRUE,FALSE,FALSE,TRUE
```

`===`は厳格な等号演算子で、両辺の値が同一であるかを判定します。
`!==`はその値を単純に反転したものです。

```
[
  10 === 10
  10 !== 10
  10 === 100
  10 !== 100
]
```
↓
```
TRUE,FALSE,FALSE,TRUE
```

単純な数値同士の比較においては、両者は同じ働きをします。

### 暗黙の型変換

`==`は左辺の型が右辺の値から想定された型と異なる場合、左辺の値を適切な型にキャストして比較します。
一方、`===`では両辺の型が異なる場合は偽を返します。

```
10 == "10"
```
↓
```
TRUE
```

```
10 === "10"
```
↓
```
FALSE
```

### 配列・オブジェクトの扱い【未実装の項目】

`==`
`===`

### 演算子オーバーライド【未実装の項目】

等号演算子のオーバーライドは`==`側にのみ存在する機能です。
`==`演算子が評価された際に右辺がオブジェクトであった場合、右辺の`(OPERATOR_EQUAL)`メソッドが呼び出されます。
この際、引数を右辺の値・左辺の値の順番で与えます。

```
four : {
  (OPERATOR_EQUAL) = right, left -> left == 4
}

4 == four, 5 == four
```

`==`演算子は右辺が主体となって行うという挙動に注意してください。
この挙動は、左辺にnullが現れる可能性があるようなケースの記述を分かりやすくします。

```
nullableObject == object
```

### NANおよび-0の扱い

どちらの比較でも、NAN同士の等価性は常に偽です。

```
[
  NAN == NAN
  NAN === NAN
]
```
↓
```
FALSE,FALSE
```

逆に0と-0の等価性は常に真です。

```
[
  0 == -0
  0 === -0
]
```
↓
```
TRUE,TRUE
```

### 連鎖 `a == b == c`

すべての等号演算子は不等号演算子と連鎖を引き起こします。

## 不等号演算子 `left > right` `left >= right` `left < right` `left <= right`

fl9には4種類の不等号演算子が存在します。
不等号演算子では数値同士の比較ができます。

### 演算子オーバーライド【未実装の項目】



### 連鎖 `a < b < c`

等価性演算子と不等号演算子は、繋げて記述した場合に、各演算子の左右を比較したのちに論理積を取るという挙動をします。

```
value : 56
10 <= value <= 100
```
↓
```
TRUE
```

この記述は次のものと概ね同等です。

```
value : 56
10 <= value && value <= 100
```

違いは、2度使われる項が1度だけ評価されて、その結果を左右の比較で使いまわすことです。
これは項の評価にかかる処理時間や副作用を抑制します。

```
currentValue : 5
getNextValue : () -> (
  currentValue = currentValue + 1
  currentValue
)

6 <= getNextValue[] <= 6
```
↓
```
TRUE
```

```
currentValue : 5
getNextValue : () -> (
  currentValue = currentValue + 1
  currentValue
)

6 <= getNextValue[] && getNextValue[] <= 6
```
↓
```
FALSE
```

## 論理演算子 `left && right` `left || right`

両辺の論理積・論理和を取ります。
`&&`演算子は`||`よりも優先的に結合します。

```
[
  FALSE && FALSE
  FALSE && TRUE
  TRUE && FALSE
  TRUE && TRUE
]
```
↓
```
FALSE,FALSE,FALSE,TRUE
```

```
[
  FALSE || FALSE
  FALSE || TRUE
  TRUE || FALSE
  TRUE || TRUE
]
```
↓
```
FALSE,TRUE,TRUE,TRUE
```

### 条件文としての論理演算子

より厳密には、論理演算子は左辺の値を評価し、その値の論理値化の値によって右辺を評価して返すかどうかを決めます。
`&&`は左辺が真の場合に右辺を、`||`は左辺が偽の場合に右辺を返します。
この際、評価されなかった右辺は副作用も起こしません。
この性質により、論理演算子はif文として利用できます。

```
a : 1

FALSE && (
  a = 2
)

a
```
↓
```
1
```

```
a : 1

TRUE && (
  a = 2
)

a
```
↓
```
2
```

## 三項演算子 `condition ? then : else`

`condition`が真だった場合に`then`を、偽だった場合に`else`を返します。

fl9には「if文」はないため、三項演算子をif文として使います。

```
a : NULL

TRUE ? (
  a = 1
) : (
  a = 2
)

a
```

## エルビス演算子 `left ?: right`

左辺がUNDEFINEDだった場合に右辺を返します。
`||`演算子とは異なり、左辺がFALSEやNULLであった場合は、そのまま左辺を返します。

この演算子はデフォルト値を与えるのに便利です。

```
obj : {
  name = UNDEFINED
}

obj.name ?: "Anonymous"
```
↓
```
Anonymous
```

## 逆エルビス演算子 `left !: right`

左辺がUNDEFINED以外だった場合に右辺を返します。
`&&`演算子とは異なり、左辺がFALSEやNULLであった場合は、そのまま左辺を返します。

この演算子はnullチェックを行うのに便利です。

```
obj : UNDEFINED

obj !: obj.name
```
↓
```
UNDEFINED
```

## try演算子 `try !? catch`

左辺でエラーが出た場合に右辺を返します。

```
"Success" !? "Caught"
```
↓
```
Success
```

```
THROW["Error!!!"]
```
↓
```
THROW: Error!!!
```

```
THROW["Error!!!"] !? "Caught"
```
↓
```
Caught
```

より厳密には、左辺の評価を試みて、成功した場合にはそのまま左辺を、失敗した場合には右辺を評価して返します。

## コンマ `item, ...`

要素を`,`で区切って並べると、各要素を順番にたどるストリームを生成します。

```
1, 2, 3 | _ * _
```
↓
```
1
4
9
```

`,`を冗長に記述すると、単に無視されます。

```
, , , 1, , , 2, 3, , , ,  | _ * _
```
↓
```
1
4
9
```

要素の無い`,`は、空のストリームを生成します。

## ラムダ式 `arguments -> body`

無名関数を作る演算子です。
関数は`function[args]`などで呼び出すことができます。

```
f : arg -> arg * 100
f[7]
```
↓
```
700
```

### 引数

引数は角括弧もしくは丸括弧で囲ってもかまいません。

```
[a] -> a * 100
```

```
(a) -> a * 100
```

引数は0個や複数個でもかまいません。
複数の引数を指定する場合、`;`か`,`で区切って並べてもかまいません。

```
[] -> 100
```

```
() -> 100
```

```
[a; b; c] -> a * b * c
```

```
(a, b, c) -> a * b * c
```

`,`で区切る場合、周囲の括弧を省略できます。

```
f : a, b, c -> a * b * c
f[2; 5; 7]
```
↓
```
70
```

### 高階関数

関数の引数に関数を与えることもできます。

```
(a -> a[b -> b * 3])[c -> c[4]]
```
↓
```
12
```

## 変数宣言 `var : val`

丸括弧の中で`:`が現れると、それは変数の宣言です。
変数は`$`などを前置することなく、直接扱うことができます。

```
a : 3
b : 4
a * b
```
↓
```
12
```

`:`は丸括弧以外の場所では異なる役割を持つことが多いです。

## 代入 `var = val`

代入により、変数などの値を変えることができます。
左辺は代入可能なものでなければなりません。

```
a : 3
a = 7
a
```
↓
```
7
```

`=`もまた、しばしば代入以外の用途に使われます。

## パイプ `stream | mapper`

`stream`の各要素を`mapper`で変換します。
`mapper`は要素を`_`として受け取るクロージャとして働きます。
fl9では、多くの言語においてmap関数として提供される機能を1文字で行うことができます。

```
1 .. 3 | _ * 100
```
↓
```
100
200
300
```

### 変数名の指定 `stream | arg => mapper`

`arg =>`で受け取る変数名を指定できます。

```
1 .. 3 | x => x * 100
```
↓
```
100
200
300
```

## 文 `line; ...` `line\n...`

丸括弧の中に現れた`;`は、その左側を文として、処理を順番に実行することを表します。
`;`の直後で改行する場合、`;`は省略してもかまいません。

次の例では、`a`が0から3回1を足されて、最後に10倍されています。
このコードは変数宣言文と代入文と式で構成されています。

```
a : 0;
a = a + 1;
a = a + 1;
a = a + 1;
a = a * 10;
a
```
↓
```
30
```

`;`を省略した場合、次のようになります。

```
a : 0
a = a + 1
a = a + 1
a = a + 1
a = a * 10
a
```

### 式と文

最後の節のあとには`;`がありません。
これは最後の`a`が、「`a`という式の値を返す」という戻り値の役割をするためです。

最後に式の無い文のみのコードは、VOIDという特殊な値を返します。
VOIDは文字列化を含むあらゆる操作が許されません。

```
100;
```
↓
```
Error: Void access
```

式は、その後に`;`を書くことでその結果を使わずに捨てることができます。
VOIDに対してはあらゆる操作ができませんが、文にすることで握りつぶすことはできます。
これは副作用のある処理を行うのに適しています。

改行で式を文にすることはできません。
明示的に`;`を記述する必要があります。

```
process1[];
(
  process2[];
  process3[];
);
result
```

一部の演算子は式状態と文状態で異なる挙動をします。

### 丸括弧と文

丸括弧の中に文が書けることはこの言語のひとつの特徴です。
この性質により、一部分に複雑な計算が挟まるような式を関数を使わずに書くことができます。

```
1 + 2 + (
  a : 500;
  a = a + 30;
  a
) + 4 + 5
```
↓
```
542
```

# consoleライブラリ

consoleライブラリは、node.js版でのみ利用可能なライブラリです。
ブラウザ版では利用できません。

## `IN`定数

標準入力をUTF-8テキストとして1行ずつ読み取り、各行の内容を順番に返すストリームです。
各要素は末尾に改行文字を含みません。
読み取り時に行の区切りとして認識される文字列は、`\r\n` `\r` `\n`のいずれです。

入力全体の末尾が改行であった場合、その改行は無視されます。

```
$ echo -en "abc\ndef\n" | fl9 'IN | "[$_]"'
```
↓
```
[abc]
[def]
```

## `READ[file]`関数

`file`を開き、内容を1行ずつ返すストリームを生成する関数です。
詳細な挙動は`IN`定数に準じます。

## `JS[code]`関数

`code`をJavaScriptとして実行します。
コード本文が返した値はそのまま`JS`関数の戻り値として受け取ることができます。

```
JS["1 + 2 + 3 + 4 + 5"]
```
↓
```
15
```

## `REQUIRE[name]`関数

nodeモジュールを呼び出します。

```
path : REQUIRE["path"]
path.resolve[
  "/abc/def"
  "ghi/jkl"
  ".."
]
```
↓
```
/abc/def/ghi
```

# コンソール

## fl9

### ソースコード全体の戻り値の出力

ソースコード全体の戻り値がVOIDだった場合、何も行いません。
そうでない場合、ソースコード全体の戻り値は文字列化されて標準出力に出力されます。

ソースコード全体の戻り値がストリームであった場合、ストリームそのものを一旦文字列化するのではなく、各要素をそれぞれ文字列化して改行付きで出力します。

### EFLモード `-e`

オプション`-e`を付けると、ソースコード全体を`%>` `<%`なしでEFLボディーとして解釈するようになります。

ソースコードの先頭に限り、`#!`で始まる行が無視されます。

## fl9e

`fl9e`は`fl9 -e -f`の省略形です。
このコマンドはCGIスクリプトを記述するのに便利です。

# イディオム

## 簡易的なCSV出力

文字列化において、ストリームは要素の間を改行で区切り、配列は要素の間を`,`で区切ります。
ストリームを文字列化しても末尾に改行は付きませんが、コンソール版ではデフォルトで出力の末尾に改行が挿入されます。
結果、配列のストリームを書くと簡易的なCSV出力となります。

```
1 .. 9 | a => [1 .. 9 | b => a * b]
```
↓
```
1,2,3,4,5,6,7,8,9
2,4,6,8,10,12,14,16,18
3,6,9,12,15,18,21,24,27
4,8,12,16,20,24,28,32,36
5,10,15,20,25,30,35,40,45
6,12,18,24,30,36,42,48,54
7,14,21,28,35,42,49,56,63
8,16,24,32,40,48,56,64,72
9,18,27,36,45,54,63,72,81
```

# 高度なチュートリアル

## オブジェクト指向

### オブジェクトの生成

オブジェクトを作るには`{ }`演算子を使います。
フィールドを定義するには、フィールド名と値を`=`で区切って書きます。

```
object : {
  field1 = 100
}

object.field1
```
↓
```
100
```

フィールドを呼び出すには`object.field`のように書きます。

### メソッド

メソッドは第一引数に自分自身を取る関数プロパティとして定義します。

```
object : {
  field1  = 100
  method1 = this    -> this.field1
  method2 = this, b -> this::method1[] + b
}

[
  object::method1[]
  object::method2[20]
]
```
↓
```
100,120
```

メソッドを呼び出すには、`object::method[arguments]`のように書きます。
メソッド内で自分の持つフィールドや別のメソッドを呼び出す場合は、第一引数に対してアクセスを行います。

## 演算子オーバーライド

fl9ではオブジェクトに特殊なパラメータを付けることで演算子の挙動をオーバーライドできます。

```
four : {
  (OPERATOR_MULTIPLY) = left, right -> 4 * right
}
four * 25
```
↓
```
100
```

項の値によって挙動を変える演算子の一部は、主軸となる項がオブジェクトだった場合に、そのオブジェクトの特殊なメソッドを呼び出します。
例えば、「加算」であれば、呼び出されるメソッドは`(OPERATOR_MULTIPLY)`です。
`OPERATOR_MULTIPLY`は加算の演算子オーバーライドに使うメソッドを表す組み込み定数です。
この挙動のため、fl9では演算子オーバーロードではなく演算子オーバーライドと呼ばれています。
演算子オーバーロードではないため、「左辺に数値を、右辺に独自オブジェクトを取るような加算演算子」のような演算子を定義することはできません。

演算子オーバーライドのメソッドは、必ず第一引数に受け手となったオブジェクト、その他の引数に演算子の他の項が渡されます。

## デバッグ

ラムダ式などの「関数を生成する場所」では、関数名および元のソースコード上での位置が付与されています。

例えばこのコードであれば、ソースコード`<EVAL>`内の`1`行目`11`文字目に由来する関数`main`を経由したことが分かります。
ソースコード上の位置の表記は1から始まります。

```
main : () -> THROW["Error!!!"]
main[]
```

```
Error: Error!!!
    v1 http://【中略】/fluorite9/build/web/release/editor.js line 44 > eval:6
    apply http://【中略】/fluorite9/build/web/release/fl9_runtime.js:108
    [main (<EVAL>:1,11)] http://【中略】/fluorite9/build/web/release/editor.js line 44 > eval:6
    apply http://【中略】/fluorite9/build/web/release/fl9_runtime.js:108
    [<ROOT> (<EVAL>)] http://【中略】/fluorite9/build/web/release/editor.js line 44 > eval:10
    compile http://【中略】/fluorite9/build/web/release/editor.js:44
    onclick http://【中略】/fluorite9/build/web/release/editor.html:1
```
